[
  {
    "Id": "437680",
    "ThreadId": "211180",
    "Html": "<p>I'm having issues with VerifyPropertyName throwing ArgumentExceptions in a particular scenario. It looks like the Conditional attribute on VerifyPropertyName should keep it from executing, but it doesn't. Is the build type determined by my Silverlight project or by the project the assemblies were built from? If its the MVVMLight project, then it looks like the assemblies you published were built as Debug.</p>\r\n<p>What I'm doing is a little different, so maybe there's a better way and I don't need to worry about this exception.</p>\r\n<p>I decided to handle validation by creating a ValidatingViewModelBase class, which inherits from ViewModelBase and implements INotifyDataErrorInfo. I override RaisePropertyChanged and kick of validations by calling the FluentValidation validator for my view model. This all works fine for basic views and view models.</p>\r\n<p>Today I'm working on a view that contains a list of items. My view model has an ObservableCollection of view models that represent those items. However, in order to get changes to those child view models to validate, I needed to handle their PropertyChanged events, and call RaisePropertyChanged on my parent view model. This is where the VerifyPropertyName throws an exception because the propertyName is from the child view model.</p>\r\n<p>Maybe there's a better way to implement validation on a list of view models?</p>\r\n<p>In case you're interested, here's what my ValidatingViewModelBase class looks like.</p>\r\n<p>\r\n<div style=\"color:black;background-color:white\">\r\n<pre><span style=\"color:blue\">public</span> <span style=\"color:blue\">class</span> ValidatingViewModelBase&lt;T&gt; : ViewModelBase, INotifyDataErrorInfo\r\n{\r\n    <span style=\"color:blue\">private</span> <span style=\"color:blue\">readonly</span> IValidator&lt;T&gt; _validator;\r\n    <span style=\"color:blue\">private</span> <span style=\"color:blue\">readonly</span> Dictionary&lt;<span style=\"color:blue\">string</span>, List&lt;ValidationInfo&gt;&gt; _errors;\r\n\r\n    <span style=\"color:blue\">public</span> <span style=\"color:blue\">event</span> EventHandler&lt;DataErrorsChangedEventArgs&gt; ErrorsChanged;\r\n\r\n    <span style=\"color:blue\">public</span> ValidatingViewModelBase() : <span style=\"color:blue\">this</span>(<span style=\"color:blue\">null</span>, <span style=\"color:blue\">null</span>)\r\n    {\r\n    }\r\n\r\n    <span style=\"color:blue\">public</span> ValidatingViewModelBase(IValidator&lt;T&gt; validator) : <span style=\"color:blue\">this</span>(validator, <span style=\"color:blue\">null</span>)\r\n    {\r\n    }\r\n\r\n    <span style=\"color:blue\">public</span> ValidatingViewModelBase(IValidator&lt;T&gt; validator, IMessenger messenger) : <span style=\"color:blue\">base</span>(messenger)\r\n    {\r\n        _validator = validator;\r\n        _errors = <span style=\"color:blue\">new</span> Dictionary&lt;<span style=\"color:blue\">string</span>, List&lt;ValidationInfo&gt;&gt;();\r\n    }\r\n\r\n    <span style=\"color:blue\">public</span> IEnumerable GetErrors(<span style=\"color:blue\">string</span> propertyName)\r\n    {\r\n        <span style=\"color:blue\">if</span> (<span style=\"color:blue\">string</span>.IsNullOrEmpty(propertyName))\r\n            <span style=\"color:blue\">return</span> _errors.Values;\r\n            \r\n        CreateValidationErrorInfoListForProperty(propertyName);\r\n        <span style=\"color:blue\">return</span> _errors[propertyName];\r\n    }\r\n\r\n    <span style=\"color:blue\">public</span> <span style=\"color:blue\">bool</span> HasErrors\r\n    {\r\n        <span style=\"color:blue\">get</span> { <span style=\"color:blue\">return</span> _errors.Count &gt; 0; }\r\n    }\r\n\r\n    <span style=\"color:blue\">protected</span> <span style=\"color:blue\">virtual</span> <span style=\"color:blue\">void</span> AddValidationErrorForProperty(<span style=\"color:blue\">string</span> propertyName, ValidationInfo validationInfo)\r\n    {\r\n        CreateValidationErrorInfoListForProperty(propertyName);\r\n\r\n        <span style=\"color:blue\">if</span> (!_errors[propertyName].Contains(validationInfo))\r\n        {\r\n            _errors[propertyName].Add(validationInfo);\r\n            RaiseErrorsChanged(propertyName);\r\n        }\r\n    }\r\n\r\n    <span style=\"color:blue\">protected</span> <span style=\"color:blue\">virtual</span> <span style=\"color:blue\">void</span> ClearValidationErrorsForProperty(<span style=\"color:blue\">string</span> propertyName)\r\n    {\r\n        CreateValidationErrorInfoListForProperty(propertyName);\r\n\r\n        <span style=\"color:blue\">if</span> (_errors[propertyName].Count &gt; 0)\r\n        {\r\n            _errors[propertyName].Clear();\r\n            RaiseErrorsChanged(propertyName);\r\n        }\r\n    }\r\n\r\n    <span style=\"color:blue\">protected</span> <span style=\"color:blue\">virtual</span> <span style=\"color:blue\">void</span> ClearAllValidationErrors()\r\n    {\r\n        <span style=\"color:blue\">foreach</span> (<span style=\"color:blue\">var</span> propertyName <span style=\"color:blue\">in</span> _errors.Keys)\r\n            ClearValidationErrorsForProperty(propertyName);\r\n        _errors.Clear();\r\n    }\r\n\r\n    <span style=\"color:blue\">private</span> <span style=\"color:blue\">void</span> CreateValidationErrorInfoListForProperty(<span style=\"color:blue\">string</span> propertyName)\r\n    {\r\n        <span style=\"color:blue\">if</span> (!_errors.ContainsKey(propertyName))\r\n            _errors[propertyName] = <span style=\"color:blue\">new</span> List&lt;ValidationInfo&gt;();\r\n    }\r\n\r\n    <span style=\"color:blue\">protected</span> <span style=\"color:blue\">void</span> RaiseErrorsChanged(<span style=\"color:blue\">string</span> propertyName)\r\n    {\r\n        <span style=\"color:blue\">var</span> handler = ErrorsChanged;\r\n        <span style=\"color:blue\">if</span> (handler != <span style=\"color:blue\">null</span>)\r\n        {\r\n            handler.Invoke(<span style=\"color:blue\">this</span>, <span style=\"color:blue\">new</span> DataErrorsChangedEventArgs(propertyName));\r\n        }\r\n    }\r\n\r\n    <span style=\"color:blue\">protected</span> <span style=\"color:blue\">override</span> <span style=\"color:blue\">void</span> RaisePropertyChanged(<span style=\"color:blue\">string</span> propertyName)\r\n    {\r\n        Validate();\r\n        <span style=\"color:blue\">base</span>.RaisePropertyChanged(propertyName);\r\n    }\r\n\r\n    <span style=\"color:blue\">protected</span> <span style=\"color:blue\">virtual</span> <span style=\"color:blue\">bool</span> Validate()\r\n    {\r\n        <span style=\"color:blue\">if</span> (_validator == <span style=\"color:blue\">null</span>)\r\n            <span style=\"color:blue\">return</span> <span style=\"color:blue\">true</span>;\r\n\r\n        ClearAllValidationErrors();\r\n\r\n        <span style=\"color:blue\">var</span> results = _validator.Validate(<span style=\"color:blue\">this</span>);\r\n\r\n        <span style=\"color:blue\">if</span> (!results.IsValid)\r\n        {\r\n            <span style=\"color:blue\">foreach</span> (<span style=\"color:blue\">var</span> failure <span style=\"color:blue\">in</span> results.Errors)\r\n            {\r\n                AddValidationErrorForProperty(failure.PropertyName, \r\n                    <span style=\"color:blue\">new</span> ValidationInfo(failure.ErrorMessage, ValidationType.Error));\r\n            }\r\n        }\r\n\r\n        <span style=\"color:blue\">return</span> results.IsValid;\r\n    }\r\n}\r\n\r\n</pre>\r\n</div>\r\n</p>",
    "PostedDate": "2010-04-30T13:09:33.193-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "437685",
    "ThreadId": "211180",
    "Html": "<p>Hey Matt,</p>\r\n<p>Yes the assemblies published now are the debug ones. The conditional compiling is always a kind of bet on which assemblies to use in which configuration, not the first time I am burned by this. Unfortunately, there is no easy way to solve this. You are right to remind me that I should publish the release version of V3 though. I will do that ASAP. In the mean time, I will send them to you per email.</p>\r\n<p>A quick fix in your (slightly unusual) situation would be to override RaisePropertyChanged in your ValidatingViewModelBase to avoid calling VerifiyPropertyName. The method is fairly simple, so overriding it seems like a good fix.</p>\r\n<p>What do you think?</p>\r\n<p>Cheers,</p>\r\n<p>Laurent</p>",
    "PostedDate": "2010-04-30T13:34:06.727-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "437690",
    "ThreadId": "211180",
    "Html": "<p>I'm already overriding RaisePropertyChanged from the ValidatingViewModelBase, but then I'm calling the base method. I think what you're suggesting is to raise the PropertyChanged event there instead of calling the RaisePropertyChanged method on ViewModelBase. That's certainly an option.</p>\r\n<p>Are you aware of any best practices for validating on controls in an ItemsControl template? I can't seem to get the controls to show an invalid state, or get a ValidationSummary control to show the validation results.</p>\r\n<p>Thanks!</p>",
    "PostedDate": "2010-04-30T13:46:21.26-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
[
  {
    "Id": "1063731",
    "ThreadId": "448866",
    "Html": "Hello everyone,<br />\n<br />\nI have spent many days stuck in a problem that I cannot solve. My application is as follows:<br />\nThe main window is divided into two &quot;ContentControls&quot; the left one is a menu with buttons that serves the user to navigate through the different views. On the right I'm showing the different windows that the user is asking for.<br />\n<br />\nThe application is running pretty fine; but my problem is that the constructor of my ViewModels are being called twice. The first time, when I instantiate the child view in the main view and the second time is done automatically from the ViewModelLocator.<br />\n<br />\nMy code is as follows:<br />\nMainViewModel.cs<br />\n<pre><code>  public class MainViewModel : ViewModelBase\n    {\n        private ViewModelBase _currentViewModel;\n        private ViewModelBase _leftViewModel;\n\n        readonly static ToolbarViewModel toolbarViewModel = new ToolbarViewModel();        \n        // !!!! Here I add all the views I want to show while navigating, and here is where the first instance is created!\n        readonly static TelemetryViewModel telemetryViewModel = new TelemetryViewModel();\n        readonly static LogsViewModel logsViewModel = new LogsViewModel();\n      \n        /// &lt;summary&gt;\n        /// Initializes a new instance of the MainViewModel class.\n        /// &lt;/summary&gt;\n        public MainViewModel()\n        {\n            LeftViewModel = MainViewModel.toolbarViewModel;\n            CurrentViewModel = MainViewModel.telemetryViewModel;\n            Messenger.Default.Register&lt;GoToPageMessage&gt;\n            (\n                this,\n                (action) =&gt; ReceiveMessage(action)\n            );\n        }\n\n        public ViewModelBase CurrentViewModel\n        {\n            get\n            {\n                return _currentViewModel;\n            }\n            set\n            {\n                if (_currentViewModel == value)\n                    return;\n                _currentViewModel = value;\n                RaisePropertyChanged(&quot;CurrentViewModel&quot;);\n            }\n        }\n\n        public ViewModelBase LeftViewModel\n        {\n            get\n            {\n                return _leftViewModel;\n            }\n            set\n            {\n                if (_leftViewModel == value)\n                    return;\n                _leftViewModel = value;\n                RaisePropertyChanged(&quot;LeftViewModel&quot;);\n            }\n        }\n\n        private object ReceiveMessage(GoToPageMessage action)\n        {\n            switch (action.PageName)\n            {\n                case &quot;LogsView&quot;:\n                    CurrentViewModel = MainViewModel.logsViewModel;\n                    break;\n                case &quot;TelemetryView&quot;:\n                    CurrentViewModel = MainViewModel.telemetryViewModel;\n                    break;\n                default:\n                    break;\n            }\n            return null;\n        }\n    }</code></pre>\n\nViewModelLocator.cs<br />\n<pre><code> public class ViewModelLocator\n    {       \n        public ViewModelLocator()\n        {\n            ServiceLocator.SetLocatorProvider(() =&gt; SimpleIoc.Default);\n            SimpleIoc.Default.Register&lt;MainViewModel&gt;();\n            SimpleIoc.Default.Register&lt;TelemetryViewModel&gt;();\n            SimpleIoc.Default.Register&lt;LogsViewModel&gt;();\n            SimpleIoc.Default.Register&lt;ToolbarViewModel&gt;();\n        }\n\n        public MainViewModel MainViewModel\n        {\n            get\n            {\n               return ServiceLocator.Current.GetInstance&lt;MainViewModel&gt;();                \n            }\n        }\n\n        public TelemetryViewModel TelemetryViewModel\n        {\n            get\n            {\n               // Here is where the second instance is created!\n                return ServiceLocator.Current.GetInstance&lt;TelemetryViewModel&gt;();\n            }\n        }\n        \n        public LogsViewModel LogsViewModel\n        {\n            get\n            {\n                return ServiceLocator.Current.GetInstance&lt;LogsViewModel&gt;();\n            }\n        }\n       \n        public ToolbarViewModel ToolbarViewModel\n        {\n            get\n            {\n                return ServiceLocator.Current.GetInstance&lt;ToolbarViewModel&gt;();\n            }\n        }  \n}</code></pre>\n\nAny comment will be very grateful. Thanks everybody!!<br />\n",
    "PostedDate": "2013-07-02T11:15:07.043-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1063980",
    "ThreadId": "448866",
    "Html": "I haven't used MVVM Light's IoC, we use Unity but the ViewModelLocator will return a new instance of the viewmodel unless you explicitly register it as a singleton in the IoC.\r<br />\n<br />\nOur app is pretty large and we have many separate modules and use Prism for the modularity side of things and MVVM LIght for all the viewmodel communication and messaging between modules.\r<br />\n<br />\nWe tend to register the module main parent view in the Ioc and when the child viewmodels get instantiated using a view 1st approach with a viewmodel locator they get the parent viewmodel from the Ioc in their constructor and set a reference to the child vm in the parent so essentially the child view sets the reference, I've checked this with a memory profiler and this works as expected (also releases ok from memory assuming you remove all your handlers etc)\r<br />\n<br />\nParent view (code behind cs file)<br />\n<pre><code>public DemoMainView(DemoMainViewModel vm)\n        {\n\n            IUnityContainer container = ServiceLocator.Current.GetInstance&lt;IUnityContainer&gt;();\n            container.RegisterInstance&lt;DemoMainViewModel&gt;(vm, new ContainerControlledLifetimeManager());\n\n            InitializeComponent();\n            this.DataContext = vm;\n\n        }\n\npublic void Cleanup(object sender, RoutedEventArgs e)\n        {\n            // Clear vm from memory\n            DemoMainViewModel vm = (DemoMainViewModel)this.DataContext;\n            if (vm != null)\n            {\n                //// Remove instance from IoC and allow Prism to unload the module\n                if (vm.KeepAlive == false)\n                {\n\n                    this.DataContext = null;\n\n                    // Remove parent class from IoC\n                    IUnityContainer container = ServiceLocator.Current.GetInstance&lt;IUnityContainer&gt;();\n                    var registration = container.Registrations.First(r =&gt; r.RegisteredType == typeof(DemoMainViewModel));\n                    registration.LifetimeManager.RemoveValue();\n                }\n                vm = null;\n                \n\n            }\n\n        }\n</code></pre>\n\nIn the child view<br />\n<pre><code>public class NotificationViewModel : GalaSoft.MvvmLight.ViewModelBase, ICleanup\n    {\n\n        \n        public NotificationViewModel()\n        {\n            // Set reference to parent view model so it can alter child vm properties\n            DemoMainViewModel parent = ServiceLocator.Current.GetInstance&lt;DemoMainViewModel&gt;();\n            parent.Notifications = this;\n            \n</code></pre>\n\nViewModelLocator<br />\n<pre><code>class DemoViewModelLocator\n    {\n        private IUnityContainer _container;\n        private IUnityContainer Container\n        {\n            get\n            {\n                if (_container == null)\n                    _container = ServiceLocator.Current.GetInstance&lt;IUnityContainer&gt;();\n                return _container;\n            }\n        }\n\n        public NotificationViewModel NotificationDemo\n        {\n            get { return Container.Resolve&lt;NotificationViewModel&gt;(); }\n        }\n\n        public ThreadingViewModel ThreadingDemo\n        {\n            get { return Container.Resolve&lt;ThreadingViewModel&gt;(); }\n        }</code></pre>\n\nIn the child view:<br />\n<pre><code>&lt;UserControl x:Class=&quot;VShips.Framework.Demo.View.ThreadingView&quot;\n             x:Name=&quot;ucThreadingView&quot;\n             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;\n             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;\n             xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; \n             xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;\n             xmlns:vm=&quot;clr-namespace:CompanyName.ApplicationName.Demo.ViewModel&quot;\n             xmlns:i=&quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity&quot;\n             xmlns:common=&quot;clr-namespace:CompanyName.ApplicationName.Common.Model;assembly=VShips.Framework.Common&quot;\n             xmlns:mvvm=&quot;clr-namespace:GalaSoft.MvvmLight.Command;assembly=GalaSoft.MvvmLight.Extras.WPF45&quot;\n             xmlns:telerik=&quot;http://schemas.telerik.com/2008/xaml/presentation&quot;\n             xmlns:scm=&quot;clr-namespace:System.ComponentModel;assembly=WindowsBase&quot;\n             mc:Ignorable=&quot;d&quot; \n             d:DesignHeight=&quot;300&quot; \n             d:DesignWidth=&quot;300&quot;&gt;\n\n    &lt;UserControl.Resources&gt;\n        &lt;ResourceDictionary&gt;\n            &lt;ResourceDictionary.MergedDictionaries&gt;\n                &lt;ResourceDictionary Source=&quot;pack://application:,,,/CompanyName.Application.Resource;Component/SharedResources.xaml&quot;&gt;&lt;/ResourceDictionary&gt;\n            &lt;/ResourceDictionary.MergedDictionaries&gt;\n\n            &lt;vm:DemoViewModelLocator x:Key=&quot;ViewModelLocator&quot; /&gt;\n        &lt;/ResourceDictionary&gt;\n    &lt;/UserControl.Resources&gt;\n\n    &lt;UserControl.DataContext&gt;\n        &lt;Binding Path=&quot;ThreadingDemo&quot; Source=&quot;{StaticResource ViewModelLocator}&quot; /&gt;\n    &lt;/UserControl.DataContext&gt;</code></pre>\n\nI think if your register your vm with a key in simple IoC you should be able to get the existing instance rather than a new one, Laurent discusses it here.\r<br />\n<br />\n<a href=\"http://stackoverflow.com/questions/7297014/does-the-mvvm-light-simpleioc-support-singletons\" rel=\"nofollow\">http://stackoverflow.com/questions/7297014/does-the-mvvm-light-simpleioc-support-singletons</a>\r<br />\n<br />\nHope this is of some assistance,\r<br />\n<br />\nTaz.<br />\n",
    "PostedDate": "2013-07-03T01:58:54.9-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1064036",
    "ThreadId": "448866",
    "Html": "Thanks very much!! Your code snippets have been very useful.\r<br />\n<br />\nFollowing your guides I have realized that I was creating instances explicitly besides the IOC container.\r<br />\n<br />\nRegards!<br />\n",
    "PostedDate": "2013-07-03T04:10:58.99-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1064043",
    "ThreadId": "448866",
    "Html": "<strong>JosepB wrote:</strong><br />\n<blockquote>\nThanks very much!! Your code snippets have been very useful.<br />\n<br />\nFollowing your guides I have realized that I was creating instances explicitly besides the IOC container.<br />\n<br />\nRegards!<br />\n</blockquote>\nYour welcome :-)<br />\n",
    "PostedDate": "2013-07-03T04:28:49.03-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
[
  {
    "Id": "1341258",
    "ThreadId": "577555",
    "Html": "Hi,\r<br />\n<br />\nhow do I create multiple instances of the same usercontrol? I have a listview and a tabcontrol. When I click a listviewitem a new tab gets created with the usercontrol as content. However when I click multiple listviewitems, all the tabs are synced with the last selected listviewitem.\r<br />\n<br />\nHow can I prevent this and make each usercontrol unique?\r<br />\n<br />\nI am using mvvm light and wpf\r<br />\n<br />\nthanks<br />\n",
    "PostedDate": "2015-01-12T14:07:13.873-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1341684",
    "ThreadId": "577555",
    "Html": "Nobody that can help me ? I have asked the same question on stackoverflow but I don't get an answer there.\r<br />\n<br />\nI have read about the fact that you can unique initialize your viewmodel in the viewmodellocator by adding a Guid to it: <br />\n<pre><code>    public DossierDetailViewModel DossierDetail\n    {\n        get\n        {\n            //return ServiceLocator.Current.GetInstance&lt;DossierDetailViewModel&gt;();\n            return SimpleIoc.Default.GetInstance&lt;DossierDetailViewModel&gt;(Guid.NewGuid().ToString());\n            //return new DossierDetailViewModel();\n        }\n    }\n</code></pre>\n\nbut I still have the same problem.\r<br />\n<br />\nAny help is appreciated<br />\n",
    "PostedDate": "2015-01-13T22:43:28.197-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1341686",
    "ThreadId": "577555",
    "Html": "Hi,\r<br />\n<br />\nIn this situation, I would assign the datacontext in code behind when you create the new tab (assuming that the tab creation is done in code).\r<br />\n<br />\nYou can use the IOC container to create the VM if you need to keep track of it in the registry. If not, you can just get it from a factory method on the main VM.\r<br />\n<br />\nThen create your Tab and use something like\r<br />\n<br />\nmyTab.DataContext = theNewVm;\r<br />\n<br />\nDoes it make sense?\r<br />\nCheers \r<br />\nLaurent<br />\n",
    "PostedDate": "2015-01-13T22:59:05.46-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1341695",
    "ThreadId": "577555",
    "Html": "Hi Laurent, thank you for your help.\r<br />\n<br />\nThe tab is indeed created in code behind. It is created with each click of a listviewitem and added to the tabcontrol. The content of the tab is a usercontrol with its own viewmodel. When I click a few listviewitems then more tabs are created but all with the same usercontrol (and thus viewmodel).\r<br />\n<br />\nThis is the XAML of the TabControl:<br />\n<pre><code>        &lt;TabControl Grid.Row=&quot;0&quot; Grid.Column=&quot;1&quot;\n            ItemsSource=&quot;{Binding Path=OpenDossiers}&quot; SelectedIndex=&quot;{Binding SelectedIndex}&quot;&gt;\n            &lt;TabControl.ItemTemplate&gt;\n                &lt;DataTemplate&gt;\n                    &lt;WrapPanel&gt;\n                        &lt;TextBlock FontSize=&quot;18&quot; Text=&quot;{Binding TabName}&quot;/&gt;\n                        &lt;Button Command=&quot;{Binding CloseDossierCommand}&quot; Content=&quot;X&quot; Margin=&quot;4,0,0,0&quot; FontFamily=&quot;Courier New&quot; Width=&quot;17&quot; Height=&quot;17&quot; VerticalContentAlignment=&quot;Center&quot; /&gt;\n                    &lt;/WrapPanel&gt;\n                &lt;/DataTemplate&gt;\n            &lt;/TabControl.ItemTemplate&gt;\n            &lt;TabControl.ContentTemplate&gt;\n                &lt;DataTemplate&gt;\n                    &lt;views:DossierDetailView /&gt;\n                &lt;/DataTemplate&gt;\n            &lt;/TabControl.ContentTemplate&gt;\n        &lt;/TabControl&gt;\n</code></pre>\n\nIt's itemsource is OpenDossiers which is an observablecollection:<br />\n<pre><code>    private ObservableCollection&lt;DossierDetailViewModel&gt; _openDossiers;\n\n    public ObservableCollection&lt;DossierDetailViewModel&gt; OpenDossiers\n    {\n        get\n        {\n            return _openDossiers;\n        }\n        set\n        {\n            _openDossiers = value;\n            RaisePropertyChanged(&quot;OpenDossiers&quot;);\n        }\n    }\n</code></pre>\n\nThe creation of a new tab is done like this:<br />\n<pre><code>            DossierDetailViewModel newDossier = new DossierDetailViewModel();\n            newDossier.TabName = SelectedDossier.Omschrijving;\n            this.OpenDossiers.Add(newDossier);\n            Messenger.Default.Send&lt;DTO.Dossier.Dossier&gt;(SelectedDossier, &quot;SetDossier&quot;);\n            SelectedIndex = OpenDossiers.IndexOf(newDossier);\n</code></pre>\n\nAs you can see the DossierDetailViewModel is the viewmodel that is used in each tab. The Messenger.Send fills a property of that viewmodel with the selected listviewitem. But when I have multiple tabs and so multiple instances of the usercontrols with the viewmodel every tabs is synced with the last selected listviewitem.\r<br />\n<br />\nI have tried it with TabItem and DataContext as you suggested but that didn't make a difference. Maybe you can see something wrong in my code or way of thinking :)<br />\n",
    "PostedDate": "2015-01-13T23:43:03.96-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1341701",
    "ThreadId": "577555",
    "Html": "Hi \r<br />\n<br />\nAt first glance it should work since the datacontext of the DataTemplate (of the TabControl) will be set to the current item in the ObsCollection.\r<br />\n<br />\nThat said I am looking at that on a mobile phone so maybe I missed something. In this scenario, setting the DataContext in code won't help you since it is automatically done at the Data Template level, and then inherited down to the user control.\r<br />\n<br />\nDo you in any place set the DataContext of the User control itself?\r<br />\n<br />\nI'll take a closer look at home.\r<br />\n<br />\nCheers\r<br />\nLaurent<br />\n",
    "PostedDate": "2015-01-14T00:08:30.14-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1341704",
    "ThreadId": "577555",
    "Html": "I appreciate your valuable time Laurent.<br />\n<br />\nThis is the xaml of my usercontrol. As you can see it has the datacontext of the viewmodel. As a quick test I put the Dossier.Omschrijving (which is a part of the object the usercontrol gets from the selected listviewitem) in a textbox:<br />\n<br />\n&lt;UserControl x:Class=&quot;eDossier.WPF.View.DossierDetailView&quot;<br />\n<pre><code>    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;\n    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;\n    xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;\n    xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;\n    xmlns:Controls=&quot;clr-namespace:MahApps.Metro.Controls;assembly=MahApps.Metro&quot;             \n    xmlns:ignore=&quot;http://www.ignore.com&quot;\n    mc:Ignorable=&quot;d ignore&quot;\n    DataContext=&quot;{Binding DossierDetail, Source={StaticResource Locator}}&quot;&gt;\n\n&lt;Grid &gt;\n    &lt;ScrollViewer &gt;\n        &lt;StackPanel Grid.Row=&quot;2&quot; Grid.Column=&quot;0&quot; Margin=&quot;0,0,0,5&quot;&gt;\n            &lt;Grid&gt;\n                &lt;Grid.ColumnDefinitions&gt;\n                    &lt;ColumnDefinition Width=&quot;auto&quot; /&gt;\n                    &lt;ColumnDefinition Width=&quot;*&quot; /&gt;\n                &lt;/Grid.ColumnDefinitions&gt;\n                &lt;TextBlock Text=&quot;Naam van het dossier&quot; Margin=&quot;5&quot; Grid.Column=&quot;0&quot; /&gt;\n                &lt;TextBox Grid.Column=&quot;1&quot; Text=&quot;{Binding Path=Dossier.Omschrijving}&quot; Controls:TextBoxHelper.Watermark=&quot;Omschrijving van het dossier&quot;/&gt;\n            &lt;/Grid&gt;\n        &lt;/StackPanel&gt;\n    &lt;/ScrollViewer&gt;\n&lt;/Grid&gt;</code></pre>\n\n&lt;/UserControl&gt;<br />\n<br />\nWith in its viewmodel the property &quot;Dossier&quot; which holds the selected listviewitem and &quot;TabName&quot; which holds the name of the tab:<br />\n<pre><code>    private DTO.Dossier.Dossier _Dossier;\n    public DTO.Dossier.Dossier Dossier\n    {\n        get { return _Dossier; }\n        set\n        {\n            _Dossier = value;\n            RaisePropertyChanged(&quot;Dossier&quot;);\n        }\n    }\n\n    private string _tabName;\n    public string TabName\n    {\n        get { return _tabName; }\n        set\n        {\n            _tabName = value;\n            RaisePropertyChanged(&quot;TabName&quot;);\n        }\n    }\n</code></pre>\n\nAnd the registration of the &quot;SetDossier&quot; Messenger which fills the selected listviewitem to the property &quot;Dossier&quot;:<br />\n<pre><code>    public DossierDetailViewModel()\n    {\n        Messenger.Default.Register&lt;DTO.Dossier.Dossier&gt;(this, &quot;SetDossier&quot;, (dossier) =&gt;\n                                           SetDossier(dossier)\n                                             );\n    }\n</code></pre>\n\nJust to be complete, here is my viewmodellocator (only with the code needed for this problem):<br />\n<pre><code>    public ViewModelLocator()\n    {\n        ServiceLocator.SetLocatorProvider(() =&gt; SimpleIoc.Default);\n\n        //Views\n        SimpleIoc.Default.Register&lt;DossierDetailViewModel&gt;();\n\n    }\n\n    public DossierDetailViewModel DossierDetail\n    {\n        get\n        {\n            return SimpleIoc.Default.GetInstance&lt;DossierDetailViewModel&gt;(Guid.NewGuid().ToString());\n        }\n    }\n\n</code></pre>\n\nThank you<br />\n",
    "PostedDate": "2015-01-14T00:30:24.93-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1341722",
    "ThreadId": "577555",
    "Html": "Hi,\r<br />\n<br />\nYes there is a flaw in your understanding of what is happening at the XAML level.\r<br />\n<br />\nin XAML, the DataContext is inherited down to the element's children. This is why, when you have (for instance) a Windows with the DataContext set, you can go to a TextBlock in this window and set Text=&quot;{Binding MyProperty}&quot;. This will automatically refer to the MyProperty on the current DataContext.\r<br />\n<br />\nThere are two kinds of viewmodels in an application. Some are larger, long lived VMs. For instance MainViewModel, SettingsViewModel, etc. These are suitable for creation and lifetime management in the ViewModelLocator (VML). \r<br />\n<br />\nBut there are also some VMs that are more transient, shorter lived, and these should probably not appear as properties in the VML. Your data items are this kind of VMs.  There are typically multiple instances of these smaller, shorter lived VMs. I call them data VMs.\r<br />\n<br />\nIn your case, your tab control's source is an ObservableCollection. Thanks to the CollectionChanged even, your UI will auto update. And thanks to the DataTemplate, the DataContext will automatically be set to the current item of the ObsCollection. This is a cool feature because you don't need to set the DataContext explicitly on the DataTemplate! In fact in most cases it is (as you found out here) impossible to set the DataContext explicity, because you don't know how to identify the right item in the collection.\r<br />\n<br />\nSo in your case, what you need to do is this:<br />\n<ul>\n<li>Remove the property in the VML. It is useless there because if doesn't provide you the right item for the current UserCOntrol.</li>\n<li>Remove the DataContext assignment in the XAML. Instead, you will simply inherit the DataContext from the usercontrol's parent, which is the DataTemplate</li>\n<li>\nIf you need design time features (in Blend or in Visual Studio), you can use the d:DataContext (design time DataContext). Check my MSDN article here: <a href=\"http://msdn.microsoft.com/en-us/magazine/dn169081.aspx\" rel=\"nofollow\">http://msdn.microsoft.com/en-us/magazine/dn169081.aspx</a><br />\n</li>\n</ul>\nThen the usercontrol's DataContext will automatically be set to the ObservableCollection's item, which is the current instance of the DossierDetailViewModel.\r<br />\n<br />\nHopefully this helps.\r<br />\n<br />\nCheers\r<br />\nLaurent<br />\n",
    "PostedDate": "2015-01-14T01:52:02.147-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": "2015-01-14T02:32:23.507-08:00"
  },
  {
    "Id": "1341739",
    "ThreadId": "577555",
    "Html": "Yes !  Spot on..thank you for your brief explanation about the XAML DataContext and escpecially about the 2 kinds of viewmodels. I thought all viewmodels had to be put in the viewmodellocator. Thanks to your info I see the difference now between the 2!<br />\n<br />\nOk so I removed the property from the VML and removed the DataContext assignment as it is inherited by the parent (DataTemplate).<br />\n<br />\nI had to do one more thing which is normal. I removed the Messenger register and send which filled the Dossier property. Because all usercontrols where registered to the same Messenger, the Dossier property always got the last one.<br />\n<br />\nThank you for your time as your time probably is very valuable. I hope someday I could do the same for you ;-)<br />\n<br />\nSerge<br />\n",
    "PostedDate": "2015-01-14T02:31:29.99-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]